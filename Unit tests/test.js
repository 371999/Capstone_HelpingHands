// Generated by Qodo Gen

describe('userRegistration', () => {

    // Successfully registers a new user with valid data
    it('register a new user and return a JWT when provided with valid data', async () => {
        const request = {
            body: {
                email: 'test@example.com',
                firstName: 'John',
                lastName: 'Doe',
                gymName: 'Fitness Gym',
                password: 'securePassword123',
                type: 'member'
            }
        };
        const response = {
            status: jest.fn().mockReturnThis(),
            json: jest.fn()
        };
        const next = jest.fn();
        const mockProfileCreate = jest.spyOn(Profile, 'create').mockResolvedValue({
            email: 'test@example.com',
            firstName: 'John',
            lastName: 'Doe',
            gymName: 'Fitness Gym',
            password: 'hashedPassword',
            type: 'member'
        });
        const mockFindOne = jest.spyOn(Profile, 'findOne').mockResolvedValue(null);
        const mockGetHashedPassword = jest.spyOn(authService, 'getHashedPassword').mockResolvedValue('hashedPassword');
        const mockGenerateJWTToken = jest.spyOn(authService, 'generateJWTToken').mockReturnValue('fakeJWTToken');

        await userRegistration(request, response, next);

        expect(mockFindOne).toHaveBeenCalledWith({ email: 'test@example.com' });
        expect(mockGetHashedPassword).toHaveBeenCalledWith('securePassword123');
        expect(mockProfileCreate).toHaveBeenCalledWith({
            email: 'test@example.com',
            firstName: 'John',
            lastName: 'Doe',
            gymName: 'Fitness Gym',
            password: 'hashedPassword',
            type: 'member'
        });
        expect(mockGenerateJWTToken).toHaveBeenCalled();
        expect(response.status).toHaveBeenCalledWith(Constants.STATUSCREATED);
        expect(response.json).toHaveBeenCalledWith({ success: true, JWT: 'fakeJWTToken' });
    });

    // Handles registration when the email already exists in the database
    it('should return an error when the email already exists', async () => {
        const request = {
            body: {
                email: 'existing@example.com',
                firstName: 'Jane',
                lastName: 'Doe',
                gymName: 'Fitness Gym',
                password: 'securePassword123',
                type: 'member'
            }
        };
        const response = {
            status: jest.fn().mockReturnThis(),
            send: jest.fn()
        };
        const next = jest.fn();
        const mockFindOne = jest.spyOn(Profile, 'findOne').mockResolvedValue({ email: 'existing@example.com' });

        await userRegistration(request, response, next);

        expect(mockFindOne).toHaveBeenCalledWith({ email: 'existing@example.com' });
        expect(response.status).toHaveBeenCalledWith(Constants.STATUSNOTFOUND);
        expect(response.send).toHaveBeenCalledWith({ error: Constants.EMAILEXISTS });
    });

    // Generates a JWT token for a newly registered user
    it('should generate a JWT token for a new user registration', async () => {
        const request = {
            body: {
                email: 'newuser@example.com',
                firstName: 'Jane',
                lastName: 'Smith',
                gymName: 'Health Club',
                password: 'strongPassword456',
                type: 'trainer'
            }
        };
        const response = {
            status: jest.fn().mockReturnThis(),
            json: jest.fn()
        };
        const next = jest.fn();
        const mockProfileCreate = jest.spyOn(Profile, 'create').mockResolvedValue({
            email: 'newuser@example.com',
            firstName: 'Jane',
            lastName: 'Smith',
            gymName: 'Health Club',
            password: 'hashedPassword',
            type: 'trainer'
        });
        const mockFindOne = jest.spyOn(Profile, 'findOne').mockResolvedValue(null);
        const mockGetHashedPassword = jest.spyOn(authService, 'getHashedPassword').mockResolvedValue('hashedPassword');
        const mockGenerateJWTToken = jest.spyOn(authService, 'generateJWTToken').mockReturnValue('fakeJWTToken');

        await userRegistration(request, response, next);

        expect(mockFindOne).toHaveBeenCalledWith({ email: 'newuser@example.com' });
        expect(mockGetHashedPassword).toHaveBeenCalledWith('strongPassword456');
        expect(mockProfileCreate).toHaveBeenCalledWith({
            email: 'newuser@example.com',
            firstName: 'Jane',
            lastName: 'Smith',
            gymName: 'Health Club',
            password: 'hashedPassword',
            type: 'trainer'
        });
        expect(mockGenerateJWTToken).toHaveBeenCalled();
        expect(response.status).toHaveBeenCalledWith(Constants.STATUSCREATED);
        expect(response.json).toHaveBeenCalledWith({ success: true, JWT: 'fakeJWTToken' });
    });

    // Hashes the password before storing it in the database
    it('should hash the password before storing it in the database', async () => {
        const request = {
            body: {
                email: 'test@example.com',
                firstName: 'John',
                lastName: 'Doe',
                gymName: 'Fitness Gym',
                password: 'securePassword123',
                type: 'member'
            }
        };
        const response = {
            status: jest.fn().mockReturnThis(),
            json: jest.fn()
        };
        const next = jest.fn();
        const mockProfileCreate = jest.spyOn(Profile, 'create').mockResolvedValue({
            email: 'test@example.com',
            firstName: 'John',
            lastName: 'Doe',
            gymName: 'Fitness Gym',
            password: 'hashedPassword',
            type: 'member'
        });
        const mockFindOne = jest.spyOn(Profile, 'findOne').mockResolvedValue(null);
        const mockGetHashedPassword = jest.spyOn(authService, 'getHashedPassword').mockResolvedValue('hashedPassword');

        await userRegistration(request, response, next);

        expect(mockFindOne).toHaveBeenCalledWith({ email: 'test@example.com' });
        expect(mockGetHashedPassword).toHaveBeenCalledWith('securePassword123');
        expect(mockProfileCreate).toHaveBeenCalledWith({
            email: 'test@example.com',
            firstName: 'John',
            lastName: 'Doe',
            gymName: 'Fitness Gym',
            password: 'hashedPassword',
            type: 'member'
        });
    });
});
